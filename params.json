{"tagline":"Hardware RNG for Papilio One based on the original Whirlygig","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Whirlyfly","google":"","body":"# Whirlyfly\r\n\r\nA hardware random number generator (RNG) for the\r\n[Papilio One](www.papilio.cc) board based on the\r\n[Whirlygig](http://warmcat.com/_wp/whirlygig-rng/).\r\n\r\n![GtkTerm does not like chaos](https://github.com/zdavkeos/whirlyfly/blob/master/doc/gtkterm_sample.png)\r\n\r\n## About\r\n\r\nThe Whirlyfly project generates random bytes and sends them over the\r\nPapilio's built-in serial port.  To generate the bits, the Whirilygig\r\nmodule is used.  Whirlygig uses a series of\r\n[unlocked inverter chains](http://en.wikipedia.org/wiki/Ring_oscillator)\r\nto generate truly random bits.  These bits are then sent over the\r\nPapilio's serial port to a host computer.  The bits can then be used\r\nin a number of different applications.\r\n\r\n## License\r\n\r\nThis code for this project comes from a variety of sources.  The code\r\nadded by me is under the GPL.  The following lists the code that is\r\nused, based on, or referenced by the project.\r\n\r\n* Whirlygig core: Andy Green @ Crash Barrier Ltd\r\n* Uart driver: Jack Gasset @ Gadget Factory\r\n* Uart core (not included, but referenced): (C) Xilinx Inc.\r\n\r\n## Quickstart\r\n\r\nThe uart side of this project is largly based on Jack Gasset's uart\r\ntutorials for the Papilio One.  I would recommend starting there if\r\nyou are unfamiliar with the process:\r\n[HighSpeedUart Tutorial](http://papilio.cc/index.php?n=Papilio.HighSpeedUART).\r\n\r\n### Building the project\r\n\r\nYou will need to follow the steps mentioned in Jack's tutorial and add\r\nthe following Xilinx uart code files to the to the project:\r\n\r\n* bbfifo_16x8.vhd\r\n* kcuart_tx.vhd\r\n* uart_tx.vhd\r\n\r\nAfter getting all the code in place, generate the bitstream as in the\r\nuart tutorial.\r\n\r\nOnce the bitstream is generated, load it on the Papilio in the usual\r\nfashion (linux): `papilio-loader -f whirlyfly.bit`\r\n\r\n## Collecting data\r\n\r\nYou _could_ use a program like minicom or\r\n[GtkTerm](https://fedorahosted.org/gtkterm/) to open the port and read\r\ndata, but it isn't going to be pretty.  What we really want is to set\r\nthe default serial port settings so we can read the data with standard\r\ntools (`head`, `dd`, `cat`, etc.)  If we don't set the default, the\r\nsystem default will be used (115200 usually).  If the baud rates\r\naren't matched, out random data won't be as random as it should be.\r\nIt will _appear_ to work correctly in this case, but if you test the\r\ndata it won't be quite right (the FIPS tests do really poorly).\r\n\r\nTo set the default settings for a serial port in Linux, use the\r\n[`stty`](http://unixhelp.ed.ac.uk/CGI/man-cgi?stty) command.  It works\r\nlike so:\r\n\r\n`stty --file=/dev/ttyUSB1 speed 3000000`\r\n\r\nOnce everything is setup, start collecting those bits!\r\n\r\n`dd bs=1K count=1000 if=/dev/ttyUSB1 of=random_bits.bin`\r\n\r\nThis will create a file called `random_bits.bin` that contains 1\r\nmegabyte of random bytes.\r\n\r\n`od -t x1 random_bits.bin | head`\r\n\r\nWill display something like:\r\n\r\n    0000000 ed 6a 5a 81 b7 13 6b 8c 4b c7 b4 ad 1d 84 13 4b\r\n    0000020 88 a7 f9 7a 20 79 e1 df 98 80 42 dc 6a 05 6b 4e\r\n    0000040 a5 95 94 00 8d 6e ce 06 84 6b ef a0 4b 9c a0 d4\r\n    0000060 de 84 64 e5 23 59 59 6c 3d 3b 59 73 cf 42 8f e8\r\n    0000100 01 38 43 45 a4 e2 0b 3a cf f7 4c 8b 01 61 ec 24\r\n    0000120 cf 8f cf 11 24 39 2e 50 1b ad 60 7a 05 ce 6a eb\r\n    0000140 cb 24 28 95 25 7a ad 73 c5 89 b7 33 b4 99 79 41\r\n    0000160 f7 90 bc 8c f5 5a f5 8f 11 50 ad 1c 96 43 19 54\r\n    0000200 85 c2 30 ae ae 8f f4 34 22 bc 01 1a 74 30 02 99\r\n    0000220 12 ee 1b d4 8e 8d 04 b7 4a 70 a4 19 ae a7 33 65\r\n\r\n### Dieharder tests\r\n\r\nIf you have Dieharder installed, you can test to see how random the\r\nfile is (though you really do need more bytes the 1M):\r\n\r\n`dieharder -a -f random_bits.bin`\r\n\r\nOr just run Dieharder against the Papilio stream directly:\r\n\r\n`dieharder -a -f /dev/ttyUSB1`\r\n\r\n### Feeding the Linux entropy pool\r\n\r\nThe\r\n[`rng-tools` package](http://sourceforge.net/projects/gkernel/files/rng-tools/)\r\nfor Linux provides the ability to feed the entropy pool from a\r\nnon-standard source.  With Whirlyfly generating the bits and\r\n`rng-tools` feeding the entropy pool, applications that use the\r\nstandard Linux interfaces can take advantage of high quality\r\nrandomness without changing a line of code.\r\n\r\nTo see if things are working, you can run `rngd` in the foreground like so:\r\n\r\n`rngd -f -r /dev/ttyUSB1`\r\n\r\nA few of the fips tests might fail (especially at first) but things\r\nshould settle out and start working quickly.\r\n\r\n## Papilio One\r\n\r\nThe original Whirlygig ran on a Xilinx CPLD and output its data in\r\nparallel using 8 I/O pins. Those pins were then periodically read by a\r\nUSB enabled microcontroller which then sent them to the host computer.\r\nThis project adapts the Whirlygig code to run on a Papilio One\r\nboard. For the Papilio, it was easiest to just use the on-board USB to\r\nserial adapter.  The Uart core is provided by Xilinx, and runs default\r\nat 3M baud.\r\n\r\n![Overview diagram](https://github.com/zdavkeos/whirlyfly/blob/master/doc/whirlyfly_overview.png)\r\n\r\nThe original Whirlygig core had to be modified slightly in order to\r\ncompile with the latest Xilinx ISE (tested with 14.1).  In addition to\r\nthe `KEEP` attribute applied to the inverters, the `SAVE` attribute\r\nhad to be applied as well.  I'm not sure if this is because of the\r\nnewer IDE or because of a different target device.\r\n\r\nFor more information on the Whirlygig core, see the\r\n[Whilygig site](http://warmcat.com/_wp/whirlygig-rng/).\r\n\r\n## Testing and Results\r\n\r\nThe code has been tested on a Papilio One 500K outputting samples at\r\n3M baud.  The output was ran against the\r\n[Dieharder](http://www.phy.duke.edu/~rgb/General/dieharder.php) test\r\nsuite.  The Papilio passed all tests, just as the original Whirlygig.\r\n\r\nRunning an entropy calculator on one 5MB sample yielded 7.988\r\nbits of entropy.\r\n\r\n![Papillio hard at work](https://github.com/zdavkeos/whirlyfly/blob/master/doc/papillio_hard_at_work.png)\r\n\r\n## Future work\r\n\r\n* Do a few more entropy tests (NIST, FIPS, etc.)\r\n* Fix it so there is only fresh data in the uart fifo\r\n* Add more documentation on the inner-workings\r\n* Test and tweak the output rate for optimal performance\r\n* Add a pre-made bitfile for really impatient users\r\n* Integrate the rng into the\r\n    [Zpuino](http://www.alvie.com/zpuino/index.html) core as a\r\n    hardware extension\r\n* Play with the RNG core, test other inverter configurations, etc.\r\n* Do some Monte-Carlo simulations\r\n"}